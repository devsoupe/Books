# 코딩 인터뷰 완전 분석 요약

http://www.yes24.com/24/goods/44305533?scode=032&OzSrank=1

다음의 내용은 `코딩 인터뷰 완전 분석`을 읽고 주관적으로 간략하게 정리한 내용입니다. 제대로된 학습을 원하신다면 책을 읽을 것을 권장해 드립니다.

---

## 1. 면접 과정

## 2. 장막 너머

## 3. 특별한 상황에서의 면접

## 4. 면접 전에

## 5. 행동 문제

---

## 6. big-O

* 이 개념은 굉장히 중요하다.
* big-O 시간은 알고리즘의 효율성을 나타내는 지표 혹은 언어이다.
* 이 개념을 모르면 알고리즘을 개발하는데 고비를 겪을 수 있고, 이전보다 빨라졌는지 느려졌는지 판단하는데 어려움을 겪을 수 있다.
* 완벽히 익혀야 하는 개념임을 기억하자.

### 비유하기

* 디스크에 있는 파일을 다른 지역에 사는 친구에게 빨리 보내야 한다고 가정한다.
* 이메일, FTP, 다른 온라인을 생각할 수 있다. 이 방법이 제일 빠를까? 맞을수도 있고 틀릴수도 있다.
* 파일 크기가 작다면 온라인을 통한 전송이 당연히 빠를것이다. 파일 크기가 1테라 이상의 큰 파일이면 어떨까?
* 파일이 엄청 크다면 비행기를 통해 물리적으로 전송하는 시간이 온라인 보다 더 짧을 수도 있다.
* 비행기 전송은 비용이 큰 문제가 되지 않을때 타당한 방법이 될것이다.

### 시간 복잡도

* 위의 비유가 점근적 실행 시간`asymptotic runtime` 또는 big-O 시간에 대한 개념이다.
* 온라인 전송은 파일 크기가 증가함에 따라 전송 시간이 선형적으로 증가한다. s를 파일 크기로 보았을때 O(s)가 된다.
* 비행기를 통한 전송은 파일 크기에 관계없이 O(1)이 된다. 파일 크기가 증가한다고 해서 전송 시간이 늘어나지 않는다. 상수 시간 만큼 소요된다.
* 눈여겨보아야 할 점은 상수가 얼마나 큰지 선형식이 얼마나 천천히 증가하는지에 관계없이 숫자가 커지다 보면 선형식은 언젠가 상수를 뛰어넘는다는 것이다.

```txt

|     / O(s)
|    /
|---/------- O(1)
|  /
| /
|/
|
|___________
```

* O(logN), O(NlogN), O(N), O(N²)... 이 외에도 다양한 실행 시간이 존재할 수 있다.
* 실행 시간에는 다양한 변수가 포함될 수도 있다. 너비가 w, 높이가 h미터인 울타리를 색칠하는 소요되는 시간 O(wh), p번의 페인트를 덧칠하는데 걸리는 시간 O(whp)이 소요된다고 말할 수 있다.
* 알고리즘의 수행 시간을 최선, 최악, 평균의 세 가지 다른 방법으로 나타낼 수 있다. 
* 퀵 정렬은 '축'이 되는 원소 하나를 무작위로 뽑아 이 보다 작은 원소는 앞에, 큰 원소는 뒤에 놓이도록 위치를 바꾼다. 그 결과 부분 정렬`partial sort`이 완성되고, 그뒤 왼쪽, 오른쪽 부분을 같은 방식으로 재귀적으로 정렬해 나간다.
```txt
* 최선인 경우 : 모든 원소가 동일하다면 퀵 정렬은 단순히 배열을 한 차례 순회하고 끝난다. 수행 시간은 O(N)이 된다.
* 최악인 경우 : 가장 큰 원소가 축이 된다면 재귀 호출이 절반 크기로 나뉘지 못하고 고작 하나(축값)가 줄어든 크기의 부분으로 배열이 나뉘게 될 수도 있다. 수행 시간은 O(N²)이 된다.
* 평균적인 경우 : 아주 멋지거나 끔찍한 경우는 자주 발생하지 않는다. 평균적으로는 O(NlogN)이 된다.
```

* 최선의 시간 복잡도는 쓸만한 개념이 아니다. 아무 알고리즘이나 특수한 입력을 넣으면 O(1)을 만들 수 있다.
* 대부분은 최악의 경우와 평균적인 경우가 같다. 다른 경우도 물론 있어 두 경우를 언급해야 할 때도 있다.

### 공간 복잡도

* 알고리즘에서는 시간뿐 아니라 메모리(공간)도 신경써야 한다.
* 공간 복잡도는 시간 복잡도와 평행선을 달리는 개념으로 크기가 n인 배열을 만든다면 O(n)의 공간이 필요하다. nxn 크기의 2차원 배열을 만들고자 한다면 O(n2)의 공간이 필요하다.
* n번의 재귀 호출에 대한 스택 공간은 스택에 쌓이는 메모리가 동시에 존재하므로 공간 복잡도 계산에 포함되어 O(n)이 된다. 하지만 반복문에서 특정함수를 n번 호출하는 것은 동시에 호출 스택에 존재하는 것이 아니므로 O(1)의 공간만 사용한다.

### 상수항은 무시하라

* O(2N)으로 표기되어야 할 알고리즘을 실제로는 O(N)으로 표기한다.
* 중첩되지 않은 2개의 루프는 O(2N)이 더 정확한 표기법이라고 생각하는 사람들이 있지만 그렇지 않다.
* 상황에 따라 O(N)이 언제나 O(2N)보다 나은 것은 아닐수 있기 때문에 상수항은 무시한다.

### 지배적이지 않은 항은 무시하라

* O(N² + N)에서 두번째 N은 틀림없이 상수항은 아니지만 그렇다고 특별히 중요한 항도 아니다. 
* 수식에서 지배적이지 않은 항은 무시해도 된다.

```txt
* O(N² + N)은 그냥 O(N²)이 된다.
* O(N + logN)은 O(N)이 된다.
* O(5 * 2의N승 + 1000N의100승)은 O(2의N승)이 된다.
```

* O(B² + A)는 A와 B사이에 존재하는 특별한 관계를 알 수 없으므로 하나의 항으로 줄일 수 없다.
* O(logX) > O(X) > O(XlogX) > O(X²) > O(2의X승) > O(X!)로 빠른 순을 정의할 수 있다.

### 여러 부분으로 이루어진 알고리즘: 덧셈 vs. 곱셈

### 상환 시간

### log N 수행시간

### 재귀적으로 수행 시간 구하기

### 예제 및 연습 문제

#### `예제 1`

아래 코드의 시간 복잡도는 어떻게 되는가?

```java
void foo(int[] array) {
  int sum = 0;
  int product = 1;
  for (int i = 0; i < array.length; i++) {
    sum += array[i];
  }
  for (int i = 0; i < array.length; i++) {
    product *= array[i];
  }
  System.out.println(sum + ", " + product);
}
```

 * O(N)이 된다. 배열을 두 번 읽든 한 번 읽든 big-O 시간을 구할 때는 아무런 영향을 주지 않는다.

#### `예제 2`

아래 코드의 시간 복잡도는 어떻게 되는가?

```java
void printPairs(int[] array) {
  for (int i = 0; i < array.length; i++) {
    for (int j = 0; j < array.length; j++) {
      System.out.println(array[i] + ", " + array[j]);
    }
  }
}
```

* 안쪽 루프의 반복 횟수는 O(N)이고 이 루프가 N번 반복된다. 총 수행시간은 O(N²)이 된다.
* 코드 의미로 보면 모든 일련의 두 원소 즉 모든 쌍`pair`을 출력하는 코드로 두 원소쌍의 총 개수는 O(N²)이므로 수행 시간은 O(N²)이 된다.

#### `예제 3`

위의 예제와 비슷하지만 안쪽 루프가 i+1부터 시작한다는 점이 다르다.

```java
void printPairs(int[] array) {
  for (int i = 0; i < array.length; i++) {
    for (int j = 0; j < array.length; j++) {
      System.out.println(array[i] + ", " + array[j]);
    }
  }
}
```

* 처음에 j는 N - 1번 반복한다. 그 다음에는 N - 2번, N - 3번, ... 이런 식으로 반복 횟수가 계속 줄어든다. 
* 따라서 총 반복 횟수는 (N - 1) + (N - 2 + (N - 3) + ... + 2 + 1 = 1 + 2 + 3 + ... + N - 1 = 1부터 N - 1까지의 합이 된다. 이는 N(N - 1) / 2가 되므로 수행시간은 O(N²)이 된다.
* 코드 의미로 보면 j가 i보다 큰 모든 (i, j) 쌍을 반복하고 있고 전체 쌍의 개수는 N²이 된다. 이 중 절반이 `i < j` 인 경우일테고 다른 절반이 `i > j`의 경우로 대략 쌍의 절발인 N² / 2개를 사용하므로 O(N²) 시간이 걸린다.

```txt
* N = 8인 경우 (i, j)쌍의 결과를 그림으로 표현하면 다음과 같다.

(0, 1) (0, 2) (0, 3) (0, 4) (0, 5) (0, 6) (0, 7)
       (1, 2) (1, 3) (1, 4) (1, 5) (1, 6) (1, 7)
              (2, 3) (2, 4) (2, 5) (2, 6) (2, 7)
                     (3, 4) (3, 5) (3, 6) (3, 7)
                            (4, 5) (4, 6) (4, 7)
                                   (5, 6) (5, 7)
                                          (6, 7)
```

* 이는 N x N의 절반 크기인 N² / 2 크기의 행렬처럼 보인다. 따라서 O(N²) 시간이 소요된다.

---

## 7. 기술적 문제

---

## 8. 합격한 뒤에

---

## 9. 면접 문제

### 자료구조

#### 01. 배열과 문자열

#### 02. 연결리스트

#### 03. 스택과 큐

#### 04. 트리와 그래프

### 개념과 알고리즘

#### 05. 비트 조작

#### 06. 수학 및 논리 퍼즐

#### 07. 객체 지향 설계

#### 08. 재귀와 동적 프로그래밍

#### 09. 시스템 설계 및 규모 확장성

#### 10. 정렬과 탐색

#### 11. 테스팅

### 지식 기반 문제

#### 12. C와 C++

#### 13. 자바

#### 14. 데이터베이스

#### 15. 스레드와 락

### 추가 연습문제

#### 16. 중간 난이도 연습문제

#### 17. 어려운 연습문제

## 10. 해법

### 10.1. 자료구조

### 10.2. 개념과 알고리즘

### 10.3. 지식 기반

### 10.4. 추가 연습문제

---

## 11. 고급 주제

## 12. 코드 라이브러리

## 13. 힌트

