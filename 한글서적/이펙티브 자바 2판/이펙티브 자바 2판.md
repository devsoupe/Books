# 이펙티브 자바 2판

http://www.yes24.com/Product/Goods/14283616?scode=032&OzSrank=3ㅁ

다음의 내용은 `이펙티브 자바 2판`을 읽고 주관적으로 간략하게 정리한 내용입니다. 제대로된 학습을 원하신다면 책을 읽을 것을 권장해 드립니다.

---

## 1장 서론

---

## 2장 객체의 생성과 삭제

* 객체를 만들어야하는 시점, 객체 생성을 피해야 하는 경우와 방법, 적절한 순간 객체가 삭제되도록 보장하는 방법, 삭제 전에 반드시 이루어져야 하는 청소 작업들을 관리하는 방법을 살펴본다.

### 규칙1 생성자 대신 정적 팩터리 메서드를 사용할 수 없는지 생각해 보라

* 객체를 만드는 일반적인 방법은 public으로 선언된 생성자(constructor)를 이용하는 것이다.
* 클래스에 public으로 선언된 `정적 팩터리 메서드(static factory method)`를 추가해서 만들 수 도 있다.

```java
// Boolean 클래스 간단한 예제
public static Boolean valueOf(boolean b) {
  return b ? Boolean.TRUE : Boolean.FALSE;
}
```

* 클래스를 정의할 때 생성자 대신 정적 팩터리 메서드를 제공할 수 있다.
* 정적 팩터리 메서드의 장점
  * 첫 번째 장점, 생성자와는 달리 정적 팩터리 메서드에는 이름(name)이 있다.

  ```txt
  - 소수(prime)일 가능성이 높은 BigInteger 객체를 생성하는 생성자 BigInteger(int, int, Random)보다는 BigInteger.probablePrime 같은 정적 팩터리 메서드 표현이 더 이해하기 쉽다.
  - 클래스는 시그너처(signature)별로 하나의 생성자만 넣을 수 있는데 이 제약을 피하려면 인자의 순서를 바꾸는 것이다. 이는 각각의 생성자 용도를 절대로 기억하지 못하고 엉뚱한 생성자를 호출하게 되는 실수를 유발하게 된다.
  ```

  * 두 번째 장점, 생성자와는 달리 호출할 때마다 새로운 객체를 생성할 필요가 없다.

  ```txt
  - 같은 객체를 반복해서 반활할 수 있으므로 특정 시점에 객체가 얼마나 존재할지를 정말하게 제어할 수 있다.
  - 이 개체 통제 클래스는 개체 수를 제어할 수 있고 이는 싱글턴, 객체 생성 불가능, 변경 불가능, 두 개의 같은 객체가 존재하지 못하도록 하는(a == b 일때만 a.equals(b)가 참이 되도록, euqlas 함수 대신 == 연사자를 사용하여 비교할 수 있으므로 성능 향상, 열거 자료형이 이 기법을 사용) 등의 클래스를 만들 수 있다.
  ```

  * 세 번째 장점, 생성자와는 달리 반환값 자료형의 하위 자료형 객체를 반활할 수 있으므로 객체의 클래스를 훨씬 유연하게 결정할 수 있다.

  // TODO

  * 네 번째 장점, 형인자 자료형(paramerterized type) 객체를 만들 때 편하다.

  ```java
  // 형인자가 늘어남에 따라 길고 복자한 코드가 만들어짐
  Map<String, List<String>> m = new HashMap<String, List<String>>();

  // 정적 팩터리 메서드를 사용하는 컴파일러가 형인자를 스스로 알아내도록 함 (type inference)
  public static <K, V> HashMap<K, V> newInstance() {
    return new HashMap<K, V>();
  }

  Map<String, List<String>> m = HashMap.newInstance();

  // 자바 1.7부터는 생성자를 호출할 때는 자료형 유추가 가능해짐. '<>' 다이아몬드 연산자는 필요
  Map<String, List<String>> myMap = new HashMap<>();
  ```

* 정적 패터리 메서드의 단점
  * 첫 번째 단점, 정적 팩터리 메서드만 있는 클래스를 만들면 public, protected로 선언된 생성자가 없으므로 하위 클래스를 만들 수 없다.

  ```txt
  - 자바의 컬랙션(Collections) 프레임워크에 포함된 기본 구현 클래스들은 하위 클래스를 만들 수 없다. 이는 오히려 하위 클래스를 만들 수 없으므로 계승(inheritance)대신 구성(composition) 기법을 쓰도록 장려한다는 측면에서 좋다고 생각 될 수도 있다. (논쟁의 소지는 있음)
  ```

  * 두 번째 단점, 다른 정적 매서드와 구분되지 않아 정적 팩터리 메서드를 통해 객체를 만들어야 하는지에 대한 클래스 사용법을 파악하기가 쉽지 않다.

  ```txt
  // TODO
  ```

* 정적 팩터리 메서드와 public 생성자는 용도가 서로 다르고 정적 팩터리 메서드가 효과적인 경우가 많으므로, 정적 팩터리 메서드 고려없이 무조건 public 생성자를 만드는 것은 지양한다.

### 규칙2 생성자 인자가 많을 때는 Builder 패턴 적용을 고려하라

---

## 3장 모든 객체의 공통 메서드

### 규칙8 equals를 재정의 할 때는 일반 규약을 따르라

### 규칙9 equals를 재정의 할 때는 반드시 hashCode도 재정의하라

### 규칙10 toString은 항상 재정의하라

---

## 4장 클래스와 인터페이스

### 규칙16 계승하는 대신 구성하라

### 규칙18 추상 클래스 대신 인터페이스를 사용하라

### 규칙19 인터페이스는 자료형을 정의할 때만 사용하라

### 규칙21 전략을 표현하고 싶을 때는 함수 객체를 사용하라

### 규칙22 맴버 클래스는 가능하면 static으로 선언하라

---

## 5장 제네릭

### 규칙25 배열 대신 리스트를 써라

---

## 6장 열거형(enum)과 어노테이션

### 규칙30 int 상수 대신 enum을 사용하라

### 규칙31 ordinal 대신 객체 필드를 사용하라

### 규칙32 비트 필드(bit field) 대신 EnumSet을 사용하라

### 규칙33 ordinal을 배열 첨자로 사용하는 대신 EnumMap을 이용하라

### 규칙34 확장 가능한 enum을 만들어야 한다면 인터페이스를 이용하라

### 규칙35 작명 패넡 대신 어노테이션을 사용하라

--- 

## 7장 메서드

### 규칙38 인자의 유효성을 검사하라

### 규칙43 null 대신 빈 배열이나 컬렉션을 반환하라

### 규칙44 모든 API 요소에 문서화 주석을 달라

### 규칙46 for 문보다는 for-each 문을 사용하라

* 릴리즈 1.5 이전의 컬렉션, 배열 순회는 다음과 같다.

```java
for (Iterator i = c.iterator(); i.hasNext(); ) {
  doSomething((Element) i.next)); // (1.5 전에는 제네릭이 없었음)
}

for (int i = 0; i < a.length; i++) {
  doSomething(a[i]);
}
```

* 릴리즈 1.5부터 도입된 for-each 문은 성가신 코드를 제거하고 반복자나 첨자변수를 완전히 제거해 오류 가능성을 없앴다.

```java
for (Element e : elements) { // ':' 기호는 "안에 있는(in)"이라고 읽는다.
  doSomething(e);
}

* for-each 문의 장점은 여러 컬렉션을 중첩할때 나타난다.

```java
// 버그가 어디 있는지 알겠는가?
enum Suit { CLUB, DIAMOND, HEART, SPADE }
enum Rank { ACE, DEUCE, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, TEN, JACK, QUEEN, KING }
...
Collection<Suit> suits = Arrays.asList(Suit.values());
Collection<Rank> ranks = Arrays.asList(Rank.values());
...
List<Card> deck = new ArrayList<Deck>;
for (Iterator<Suit> i = suits.iterator(); i.hasNext(); )
  for (Iterator<Rank> j = ranks.iterator(); j.hasNext(): )
    deck.add(new Card(i.next(), j.next())) // i.next는 원래 4번만 반복되길 원했으나 카드숫자별로 한 번씩 호출되어 NoSuchElementException이 발생

// 같은 버그, 다른 증상
enum Face { ONE, TWO, THREE, FOUR, FIVE, SIX }
...
Collection<Face> faces = Arrays.asList(Face.values());
...
for (Iterator<Face> i = faces.iterator(); i.hasNext(); )
  for (Iterator<Face> j = faces.iterator(); j.hasNext(); )
      System.out.println(i.next() + " " + j.next()); // 36개의 조합을 원했으나 6개만 출력

// 고치긴 했는데 코드가 보기 싫다 - 이보다는 잘 할 수 있다!
for (Iterator<Suit> i = suits.iterator(); i.hasNext(); ) {
  Suit suit = i.next();
  for (Iterator<Rank> j = ranks.iterator(); j.hasNext(); )
    deck.add(new Card(suit, j.next()));
}
```

* for-each 문을 중첩하는 간결한 코드로 문제를 해결할 수 있다.

```java
for (Suit suit : suits)
  for (Rank rank : ranks)
    deck.add(new Card(suit, rank));
```

* for-each 문으로 컬렉션, 배열뿐 아니라 Iterable 인터페이스를 구현하는 어떤 객체도 순회할 수 있다.
* Iterable 인터페이스는 구현하기 어렵지 않다. 원소들의 그룹을 나타내는 자료형을 작성할 때는, Collection은 구현하지 않더라도 Iterable은 구현하는게 좋다.

```java
public interface Iterable<E> {
  // 이 Iterable 안에 있는 원소들에 대한 반복자 반환
  Iterator<E> iterator();
}
```

* for-each 문은 전통적인 for 문에 비해 명료하고 버그 발생 가능성도 적으로 성능도 for 문에 뒤지지 않는다.
* for-each 문을 적용할 수 없는 경우를 제외하고 가능하다면 항상 for문 대신 for-each문을 사용해야 한다. (아래의 경우는 for 문을 사용하되, 위에서 언급한 여러 문제들을 회피하도록 해야 한다)
  * 필터링 - 컬렉션을 순회하다가 특정한 원소를 삭제할 필요가 있는 경우
  * 변환 - 리스트나 배열을 순회하다가 그 원소 가운데 일부 또는 전부의 값을 변경할 필요가 있는 경우
  * 병렬 순회 - 여러 컬렉션을 병렬적으로 순회해야 하고, 모든 반복자나 첨자 변수가 발맞춰 나아가도록 구현해야 할 필요가 있는 경우

---

## 8장 일반적인 프로그래밍 원칙들

### 규칙49 객체화된 기본 자료형 대신 기본 자료형을 이용하라

### 규칙52 객체를 참조할 때는 그 인터페이스를 사용하라

### 규칙56 일반적으로 톹용되는 작명 습관을 따르라

---

## 9장 예외

### 규칙57 예외는 예외적 상황에만 사용하라

### 규칙60 표준 예외를 사용하라

### 규칙61 추산화 수준에 맞는 예외를 던져라

### 규칙62 메서드에서 전져지는 모든 예외에 대해 문서를 남겨라

---

## 10장 병행성

### 규칙66 변경 가능 공유 데이터에 대한 접근은 동기화하라

### 규칙68 스레드보다는 실행자와 태스크를 이용하라

### 규칙69 wait나 notify 대신 병행성 유틸리티를 이용하라

---

## 11장 직렬화

### 규칙78 직렬화된 객체 대신 직렬화 프락시를 고려해 보라