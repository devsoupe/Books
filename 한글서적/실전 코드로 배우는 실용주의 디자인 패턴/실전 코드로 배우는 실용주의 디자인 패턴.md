
# 실전 코드로 배우는 실용주의 디자인 패턴 요약

<img src="http://image.yes24.com/momo/TopCate50/MidCate09/4984386.jpg">

http://www.yes24.com/Product/Goods/2127215

다음의 내용은 `실전 코드로 배우는 실용주의 디자인 패턴`을 읽고 주관적으로 간략하게 정리한 내용입니다. 제대로된 학습을 원하신다면 책을 읽을 것을 권장해 드립니다.

---

## `0. 소프트웨어 설계의 고고학`

---

## `1. OO와 디자인패턴 기초 다지기`

```text
💡 실용주의 관점에서 패턴을 설명한다.
```

- 디자인 패턴은 건축학에서 유래하였다.

- GoF 책은 분명 기념비적인 객체지향(OO) 서적이다. 하지만 실용성이 떨어진다는 단점이 있다. 이 책는 '실용주의' 관점에서 패턴을 설명하고자 한다.

---

### 패턴 vs. 이디엄

```text
💡 자주쓰여 내장되면 이디엄이 된다.
```

- 패턴이 일상적으로 사용되면, 특히 언어에 내장되면 이디엄이 된다.

---

### 디자인 패턴이란 무엇인가?

```text
💡 특정 디자인 문제를 해결하다 '반복적'으로 '발견'된 것을 디자인 패턴이라 할 수 있다.
```

- 패턴은 발명되는 것이 아니라 발견되는 것이다.

- 성공적인 프로젝트에서 여러 프로그래머들이 작성한 다양한 프로그램에서 '반복적'으로 '발견'되어야 패턴이라 할 수 있다.

- 패턴은 특정 디자인 문제를 해결하기 위해 사용된 해결 방법들을 '일반화'한 것이다.

- 패턴은 일반적인 해결 방법이기 때문에 복사&붙여넣기로 사용하는 것은 불가능하다.

- GoF가 패턴을 설명하기 위해 사용한 코드가 패턴 자체는 아니다.

- 패턴은 다양한 방식으로 실체화할 수 있다.

- 하나의 클래스가 여러 패턴의 실체화에 참여할 수 있다.

- 패턴의 정적 구조(클래스 다이어그램)보다는 '패턴의 의도'와 '동적 행동 양식'이 중요하다.

- 패턴의 의도가 중요하다. 의도를 만족시킨다면 구조에 상관없이 합당한 실체화라 할 수 있다.

- 하나의 아이디어는 수만 가지 방법으로 실체화 할 수 있다.

- 패턴을 실체화한다는 것은 패턴을 '인스턴스화' 혹은 '구현'한다는 의미가 아니다.

- '교차 통풍' 패턴(아이디어)은 다양한 방식으로 실체화할 수 있다. 하지만 의도의 '일부'만을 만족시키는 실체화는 합당한 실체화가 아니다.

- '코너 오피스' 패턴 역시 다양한 방식으로 실체화할 수 있다.

- 남서촉 창은 '교차 통풍' 패턴과 '코너 오피스' 패턴에 모두 참여한다. 패턴은 고립된 섬이 아니다. 즉 어떤 문제를 해결하기 위해 두 개 이상의 패턴을 함께 사용하는 경우가 많은 것이다. 이때 특정 객체 혹은 클래스가 두 개 이상의 패턴에 참여할 수 있다.

- 구조만으로 패턴을 파악하기는 어려우며 항상 의도를 함께 보야야 한다.

- 패턴은 디자인으로 실체화되고, 디자인은 구현으로 실체화된다. 이때 실체화는 다양한 방법으로 할 수 있다. 그러므로 패턴을 복사해 붙여넣을 수 있다는 말은 넌센스이다.

---

### 패턴, 무엇이 좋은가?

```text
💡 패턴은 '의사소통의 경제성'을 제공한다.
```

- GoF 책의 첫인상은 그리 좋지 않았다.

- 한 프로젝트 미팅에서 패턴을 사용한 '의사소통의 경제성'에 매료되었다.

- 패턴을 사용하니 패턴을 사용하지 않았을 때보다 훨씬 빨리, 더 완성도 높은 디자인을 할 수 있었다. '디자인의 경제성'이라 할 수 있을 것이다.

- 그 후 내가 구할 수 있는 패턴에 관한 모든 자료를 읽어 보았다. '의사소통의 경제성'과 '디자인의 경제성'외에 무엇을 더 바라겠는가?

---

### 디자인에서 패턴의 역할

```text
💡 디자인을 구현레벨로 이끈다.
```

- 패턴은 구현에 대해 생각하기 시작할 때 등장하게 된다.

- 건축 계획은 축조와 관련한 세부 사항까지 설명하지 않는다.

- 디자인 패턴은 보통 디자인 문서에는 나타나지 않으며, 구현 레벨에서 프로그래머가 사용하게 된다.

- 매우 복잡한 시스템의 경우 패턴을 디자인 문서에 상세히 기술하는 경우도 있다.

> **패턴의 단순함 사이의 긴장**

- 패턴에는 장점과 단점이 모두 있다. 특히 패턴은 시스템을 복잡하게 만드는 경향이 있다. 그러므로 패턴을 사용할 때는 장단점을 모두 고려한 후 도입 여부를 결정해야 한다.

- 미래의 요구 사항을 억측하여 시스템을 복잡하게 만들지 말자. 현재의 요구 사항만을 충실히 반영하여 단순한 프로그램을 만들되 학장과 수정이 용이한 구조를 유지해야 한다.

- 단순함을 위해 꼭 필요한 완전성까지 희생하면 안 된다.

- 단순함, 완전성, 수정의 용이성은 서로 충돌하기도 한다. 경험과 학습을 통해 올바른 선택 능력을 키우는 수밖에 없다.

- 인터페이스는 도입 비용은 낮은 데다 효용은 크기 때문에 적극 활용해 볼 만하다. 자주 변하는 구체 클래스 대신 인터페이스를 사용하라는 '의존 관계 역전의 원칙'을 생각하자.

---

### 패턴 분류하기

```text
💡 패턴의 분류는 정적인 구조대신 의도에 초점을 맞춰야 한다.
```

- GoF의 패턴 분류가 유명하기는 하지만 GoF의 패턴을 다른 기준으로 분류할 수도 있다.

- 우선 객체패턴과 클래스 패턴으로 분류한다.

- 객체 패턴의 수가 단연 클래스 패턴의 수를 앞서는 것은 우연이 아니다.

- 다시 생성, 구조, 행위를 기준으로 나눈다.

- 생성 패턴은 객체의 생성과 관련한 문제를 다룬다.

- 구조 패턴은 정적 모델 패턴으로 프로그램의 구조적 구성을 다룬다.

- 행위 패턴은 동적 모델 패턴으로 런타임 시에 상호 작용하는 객체들 같의 문제를 다룬다.

<img src="https://miro.medium.com/max/1400/1*z7OjQWHRclHDVSSTfja3jw.png">

- GoF의 디자인 패턴 분류GoF 패턴 이외에도 다양한 카테고리의 패턴이 존재한다.

- 패턴은 고립된 섬이 아니다. 이들은 서로 연관되어 있으며, 함께 사용하는 경우가 많다.

- 패턴 간의 연관성과 의존성 때문에 한 패턴을 다른 패턴과 구분하기 어려울 수도 있다. 이럴 경우에는 정적 구조 대신 패턴의 의도에 초점을 맞추기 바란다.

> **디자인 일반**

- 객체 지향 디자인과 객체 지향 프로그래밍은 상당히 다르다.

- 많은 프로그래머들이 코딩에는 능숙하지만 디자인 프로세스에 대해서는 제대로 이해하고 있지 못하다.

- 이 책은 객체 지향 디자인 프로세스에 대해서는 상세히 다루지 않는다. 이책은 OO 디자인을 구체적 구현으로 옮기는 방법에 대한 것이지 OOD에 대한 것이 아니다.

> **자바를 C언어 스타일로 프로그래밍하기**

- 절차 지향 시스템은 계층 구조가 깊고 큰 경향이 있으며 '전역 제어'가 주를 이룬다.

- 전역 제어는 많은 양의 테이터 흐름과 강결합 관계를 야기한다. 이 때문에 절차 지향 시스템은 일반적으로 디버깅과 유지 보수가 어렵다.

- 객체 지향 시스템은 상호 협동하는 에이전트들로 구성되며 전역 제어를 담당하는 귀족 객체는 드물다.

- 객체는 외부에 공개할 필요가 없는 데이터와 구현은 최대한 캡슐화(은닉)해야 한다(데이터 추상화, 구현 은닉).

- 절차 지향 시스템은 전역 제어로 인한 강결합으로 인해 한곳에서 일어난 변화가 시스템 전반에 퍼져나가는 경향이 있다.

- 객체 지향 시스템은 객체들이 각각의 책임을 캡슐화하여 맡고 있기 때문에 시스템의 변화가 한곳에 집중되는 경향이 있다.

- 익숙한 것이 올바른 것은 아니다.

- EJB나 스트럿츠가 특정 방식으로 문제를 해결했다고 해서 그러한 해결 방식이 항상 올바른 것은 아니다.

- 마이크로소프트의 MFC는 개발자들의 이해를 돕기 위해 의도적으로 C++를 이용하여 절차 지향 시스템을 만들었다.

- 객체 지향 시스템에 절차 지향적인 사고를 적용하지 말자. 물론 언제나 OO 솔루션을 도입해야 하는 것은 아니다. 단순하고 유지 보수의 문제가 없는 프로그램이라면 절차 지향 프로그래밍으로도 족하다. 상황에 맞게 올바른 선택을 하되 어슬픈 객체 지향 시스템을 만들지는 말자.

> **열린 눈으로 프로그래밍 하기**

- 디자인은 선택과 트레이드 오프, 리스크 관리의 연속이다.

- 어떤 선택의 좋고 나쁨은 상대적인 것이며 전체 기준의 맥락 안에서 신중히 판단해야 한다.

- IBM, 선 등에서 만든 프로그램의 디자인이나 코딩 방식이 항상 올바른 것은 아니다. 개발자의 미숙 혹은 마케팅과 정치적 이유로 특정 디자인이나 기술을 지지할 수도 있다. 여러분은 이와 같은 다지인, 코딩 방식, 이디엄 등을 도입했을 때의 이점과 폐해를 고려하여 현명한 선택을 할 수 있는 열린 눈을 갖고 있어야 한다.

---

### 객체란 무엇인가?

```text
💡 런타임시 메시지 통신을 하는 기능의 집합체이다.
```

- 시스템이 전체적으로 객체 지향적이 아니면서 일부에 패턴을 적용한다면 큰 효과를 기대하기 어려울 뿐더러 시스템을 복잡하게만 만들 수도 있다. 어설피 패턴을 적용하기 전에 객체란 무엇인가에 대해 확실하게 짚어 보고 넘어가자.

> **허튼 소리!**

- 객체 지향 프로그래밍에서 가장 오용되고 있는 용어는 '객체'이다.

- 클래스 지향 디자인이 아닌 객체 지향 디자인을 해야 한다. 즉 정적인 구조보다 런타임 시에 메시지 통신을 하는 지능적인 동물인 객체와 이들 간의 관계를 생각하자.

- 객체 지향 디자인에서 가장 근본적인 원리는 데이터와 구현을 은닉(캡슐화)하여 프로그램에 흘러 다니는 데이터의 양을 최소화하고 불필요한 의존 관계를 맺지 않는 것이다. 각각의 객체가 높은 응집도를 유지 하면서 객체들이 낮은 결합 관계를 지니도록 노력하자.

> **객체는 기능의 집합이다**

객체는 '어떻게(구현 상세)'가 아닌 '무엇을(외부와의 계약)' 할 수 있느냐에 의해 정의된다. 객체는 기능의 집합이자 서비스 제공자이다. 이때 어떻게 무슨 서비스를 제공하는지는 외부에 노출시키지만 어떻게 서비스를 제공하는지는 숨겨야 한다.

```text
제1 지령

객체에 어떤 작업을 하는 데 필요한 정보를 요청하지 말라. 대신 작업을 하는 데 필요한 데이터를 갖고 있는 객체에 일을 해달라고 요청하라. (정보가 아닌 도움을 요청하라)

1. 객체는 '계약(contract)'에 의해 정의되며, 객체는 그들이 맺은 계약을 위반해서는 안 된다.

2. 모든 데이터는 private이어야 한다. 이 법칙은 데이터뿐 아니라 모든 구현 상세에도 적용된다.

3. 변화가 아무리 클지라도 객체의 구현 방식을 객체를 정의하는 단 하나의 클래스만을 수정해 반영할 수 있어야 한다.

4. 부적절히 사용된 'get', 'set' 메소드는 사악하다. 이들은 단지 데이터를 public으로 만들 뿐이다.

물론 '무엇'을 의미하는 인터페이스가 바뀌면 변화가 외부로 퍼져 나갈 수밖에 없다. 반면 객체가 작업을 '어떻게' 하느냐를 결정하는 구현 방식은 외부와의 '계약'을 준수하는 한 어떤 방식으로든 수정할 수 있다.
```

- 중요한 것은 원리를 얼마나 올바르게 적용하고 있는가이지 어떤 언어를 사용하고 있는지가 아니다.

- 객체가 다른 객체와 맺은 계약은 해당 객체가 '무엇을' 할 수 있는지, 즉 무슨 서비스를 제공할 수 있는지에 대한 약속이며 인터페이스는 계약의 일부이다.
- '어떻게' 서비스를 제공하는가에 해당하는 구현은 계약의 일부가 아니다. 그러므로 계약이 바뀌지 않는한 구현은 마음대로 바꿀 수 있어야 한다.

> **어떻게 잘못하고 있는가?**

- 객체 지향 시스템은 보통 절차 지향 시스템보다 복잡하지만 유지 보수가 쉽다. 복잡성을 제거하지는 못하지만 조직화하여 관리하기 때문이다.

- 객제 지향적인 해결 방식은 변화와 확장의 (가능성이 높은) 부분을 캡슐화하려 시도한다. 캡슐화되어 있는 부분에서 변화나 확장이 일어나게 되면 시스템의 다른 부분에 영향을 미치지 않기 때문이다.

```text
1. 향후 변화하거나 확장될 가능성이 높은 책임을 찾아낸다. 이때 하나의 객체는 하나의 책임만을 맡아야 한다(단일 책임의 원칙 - SRP).

2. 특히 확장의 가능성이 높다면 외부와의 계약을 의미하는 인터페이스를 정의하여 구체 클래스 대신 인터페이스에 의존하도록 한다(의존 관계 역전의 원칙 - DIP). 

3. 이렇게 하면 수정에는 닫혀 있고 확장에는 열려 있는 구조가 된다(개발 폐쇄의 원칙 - OCP). 

4. 이때 인터페이스를 구현 상속하는 클래스들이 인터페이스가 약속한 연산을 모두 제공해야 한다. 만약 특정 연산 등에서 무조건 예외를 던진다면 이는 계약을 어기는 것이기 때문이다(리스코프 대체 원칙 - LSP)
```

- MVC 구조에서는 너무 많은 데이터가 흘러 다니기 때문에 객체 혹은 컴포넌트 간의 결합도가 높아진다.

> **어떻게 '올바르게' 할 수 있는가?**

- 절차 지향적 데이터베이스 프로그래머는 서버를 데이터 저장소로 보고 클라이언트를 데이터 요청자로 생각한다.

```text
1. 사용자가 ATM으로 다가가 현금 카드를 삽입하고 비밀 번호를 입력한다.

2. ATM은 '이 카드의 비밀 번호를 알려줘'를 의미하는 쿼리를 만들어 데이터베이스에 보낸다. 그리고 반환된 비밀 번호를 사용자가 입력한 비밀 번호와 비교해 본다. 사용자 비밀 번호는 SQL 쿼리에서는 문자열 타입이지만 반환되어 오는 값은 비교를 쉽게 하기 위해 16비트 int 타입이다.

3. 사용자는 예금 인출을 요청한다.

4. ATM은 또 다른 쿼리를 만든다. '이 사용자의 예금 잔액을 알려줘.' 반환 값의 타입은 32비트 int이다.

5. 잔액이 예금을 인출할 정도로 충분하다면 잔액에서 인출액을 뺀 후 서버에 '이 사용자의 잔액을 x값으로 업데이트 해줘'라 요청한다.
```

절차 지향 방식은 '이 사용자의 예금 잔액을 알려줘'와 같이 어떤 작업에 필요한 데이터를 요청한다. 이 때문에 데이터가 불필요하게 많이 흐르게 되며 결합도가 높아져 시스템의 전반적인 유지 보수성이 나빠진다. 이는 전역 제어의 폐해이기도 하다.

- OO 가 이런 문제를 어떻게 해결해주는지를 설명하기 위해 ATM 예제를 객체 지향 방식으로 재구성해 보자. OO 시스템은 기능을 가진 객체들이 협동함으로써 구성되는 시스템이다.

- OO 디자인에서는 해결하려는 문제를 '문제 도메인'의 관점에서 정의한 문제 기술서를 작성해 본다.

```text
1. 고객이 은행으로 들어와 행원으로 부터 출금 요청서(withdrawal slip)를 받아 기재한다.

2. 기재를 마친 고객은 행원(teller)에게 가서 자신의 신원을 증명한 후 출금 요청서를 건넨다.

3. 이때 행원은 은행의 거래 이력 자료(bank records)를 통해 고객의 신원을 확인한다.

4. 행원은 상사(bank officer)로 부터 승인을 받은 후 고객에게 돈을 인출해 준다.
```

문제 기술서를 통해 '핵심 추상화'(클래스들)와 연산들을 정리한다.

```text
----- BankRecords -----

• 책임

WithdrawalSlip을 생성한다. 

고객이 제시한 신분이 맞는지 검증한다.

• 협업자

Teller : 빈 출금 서식서를 요청한다.

----- BankOfficer -----

• 책임

출금을 승인한다.

• 협업자

Teller : 승인을 요청한다.

----- WithdrawalSlip -----

• 책임

Teller가 요청한 액수를 기록한다.

• 협업자

BankRecords : 출금 서식서를 생성한다.

BankOffer : 출금을 인증한다.

Teller : 고객에게 출금 서식서를 보여준다.

----- Teller -----

• 책임

BankRecords로 부터 WithdrawalSlip을 가져온다.

인증을 위해 BankOfficer에 넘긴다.

• 협업자

Teller : 승인을 요청한다.
```

OO ATM 시스템은 앞의 문제 기술서를 메시지 흐름으로 모델링 한다.

```text
1. 빌 게이츠가 ATM으로 다가와 카드와 비밀 번호를 제시하고 인출을 요청한다.

2. Teller 객체는 서버 측 BankRecords 객체에 문의한다. '이 카드와 비밀 번호를 가진 사람이 합법적인 고객입니까?

3. BankRecords 객체는 '예' 혹은 '아니오'로 답변해 준다.

4. Teller 객체는 BankRecords 객체에 빈 WithdrawalSlip을 요청한다. 이 객체는 WithdrawalSlip 인터페이스를 구현하는 클래스의 인스턴스일 것이며 RMI를 
통해 BankRecords 객체로부터 Teller 객체에 값으로(by value) 넘겨질 것이다. 이것이 중요하다. Teller가 객체에 대해서 아는 모든 것은 객체가 구현하고 있는 
인터페이스이다. 실제 구현(.class 파일)은 통신망을 타고 넘어오며 Teller는 자신이 이 객체에 보낸 메시지가 실제로 어떻게 처리되는지를 알 수 없다. 이런 추상화를 통해 Teller를 변경하지 않으면서도 WithdrawalSlip 객체를 변경할 수 있다.

5. Teller 객체는 WithdrawalSlip 객체에 사용자 인터페이스를 표현하라고 요청하고, WithdrawalSlip 객체는 AWT를 사용하여 ATM 화면에 UI를 표현하는 것으로 요청에 응한다.

6. Bill이 WithdrawalSlip을 작성한다.

7. Teller 객체는 입력이 완료 되었음(아마도 OK 버튼을 모니터링 할 것이다)을 알아차리고 입력된 WithdrawalSlip 객체를 서버 측 BankOfficer 객체에 '이 액수의 금액을 인출해 줄 수 있습니까?'라는 메시지의 인자로 넘긴다(이 역시 RMI를 사용하며 값으로 넘어간다).

8. 서버 측 BankOfficer 객체는 '예' 혹은 '아니로'로 대답한다.

9. 만약 대답이 '예'이면 ATM이 돈을 인출해 준다.
```

OO는 이처럼 잔액과 비밀 번호의 저장, 예금 인출 인증들을 객체들 안에 숨긴다.

- 객체 지향 방식은 '이 액수의 금액을 인출해 줄 수 있습니까?'와 같이 작업을 하는데 필요한 데이터를 갖고 있는 객체에게 일을 해달라고 요청(위임)한다. 각 작업은 특정 책임을 맡은 객체가 처리하며(분권 제어) 한곳에서 일어난 변화가 다른 곳으로 파급되지 않기 때문에 유지 보수성이 높아진다.

---

### 셀룰러 오토마타

```text
💡 부분 문제를 해결해 전체 문제를 해결한다.
```

- 셀룰러 오토마타에서는 각 셀이 전체 문제에 대해서는 알지 못하며 인접 셀과 정해진 규칙에 의해 통신할뿐이지만 이러한 과정 속에서 전체 문제가 해결된다.

- 셀룰러 오토마타는 문제를 해결하는 하나의 복잡한 알고리즘 대신 부분 문제를 해결하는 단순한 알고리즘들의 상호 작용을 통해 전체 문제를 해결하게 된다.

```text
예를 들어 전체 도시의 교통 흐름을 모델링하는 대신 도로의 일부분을 분리해내어 이부분만을 모델링한다. 그리고 도로의 일부는 다른 도로의 일부와 통신함으로써 합쳐지고, 각 부분은 도시 전체의 도로에 대해서는 아무 것도 알지 못한다.
```

- 교통 시물레이션에서의 객체들에는 다음과 같은 특징이 있다.

```text
• 계약, 즉 인터페이스를 통해 통신한다.

• 정보를 요청하는 대신 도움을 요청함으로써, 즉 위임을 통해 문제를 해결한다.

• 자신의 UI를 생성한다.
```

- 클래스와 클래스 간의 관계를 디자인하기 전에 객체들 간의 메시지 흐름을 먼저 이해해야 한다. 클래스 지향 디자인이 아닌 객체 지향 디자인을 생각하라.

---

### 접근 메소드와 수정 메소드는 나쁘다

```text
💡 접근 메소드와 수정 메소드는 꼭 필요한 곳이 아니면 사용하지 않는 것이 좋다.
```

- 객체는 내부 데이터와 구현을 노출시키면 안 된다. 접근 메소드와 수정 메소드는 내부 데이터와 구현을 노출시키므로 유지 보수에 악영향을 미치며, 가능한 사용하지 말아야 한다.

- 접근 메소드와 수정 메소드는 보통 해결하고자 하는 문제를 명확히 파악하지 못했음을 나타낸다.

- Money 클래스와 System.out, System.in의 예를 보면 접근 메소드 혹은 데이터 노출이 유지 보수성을 떨어뜨린다는 사실을 알 수 있을 것이다.

- 필드를 private로 만들고 public get/set 메소드를 추가하는 것은 코드를 복잡하게 만들 뿐 대개 아무런 이득도 없다.

- 객체들 간의 관계를 세심히 디자인하였다면 대부분의 클래스는 get/set 메소드를 필요로 하지 않는다.

- get/set 메소드는 대부분 객체들이 상호 작용하는 동적인 모델을 깊이 있게 생각하지 않고, '추측에 의한 디자인'을 할 때 탄생된다.

- 정적 모델링에 앞서 동적 모델링을 하고, 어떻게 할 것인가가 아닌 무엇을 필요로 하는가에 초점을 맞추도록 하자.

> **스스로를 표현하라**

- 객체가 스스로를 표현해야 한다는 주장은 충격적으로 들릴 것이다.

- 객체가 스스로를 표현하더라도 내부 클래스나 여러 디자인 패턴을 이용하여 비지니스 로직과 UI 코드를 효과적으로 분리시킬 수 있다.

- 객체가 스스로를 표현한다면 객체의 표현(UI 등)을 사용하는 코드에 영향을 미치지 않으면서도 객체의 내부와 객체의 표현을 변경할 수 있다.

> **자바빈즈와 스트럿츠**

- 앞에서 이야기한 것처럼 익숙한 것과 올바른 것은 다른 것이다. 열린 눈으으로 프로그래밍할 수 있는 능력을 키우자.

> **리팩토링**

- 리팩토링이 get/set 메소드로 인해 발생하는 모든 문제를 해결해 줄 수는 없다.

- get/set 메소드가 남용되고 있는 코드는 객체와 객체 간의 관계가 조악하게 되자인되었음을 나타낸다. 이는 리팩토링이 아니라 프로그램을 다시 디자인해야 함을 의미한다.

스트링 클래스의 OO 적인 디자인은 많은 문제를 해결해준다.

```java
String s = "hello world";

s.print(String.TO_CONSOLE);

s.load(String.FROM_CONSOLE);

• 바이트, 유니코드의 모든 문제도 스트링 클래스 구현 안으로 사라진다.

• print, load를 오버로딩하면 파일 I/O까지 다룰 수 있다.

• 이와 같은 디자인은 System.out에 대한 get/set을 제거한다.
```

>**get/set 없는 삶**

- get/set을 없애는 해결방법은 코딩이 아닌 사고의 전환인 디자인에 있다.

- OO 디자인 프로세스는 유스케이스를 중심으로 진행된다. '로그 온'은 문제 영역에서 유용한 결과를 내놓지 않으므로 유스케이스라 할 수 없다.

- '급료 수표 발행', '예금 예치하기'등은 유스케이스라 할 수 있다.

- 커닝험은 CRC 카드로 디자인 프로세스를 보여주는 방법론을 만들었다.

세 개의 섹션으로 구성된 인덱스 카드 집합을 만든다.

```text
1. 클래스(Class) : 객체의 템플릿인 클래스 이름

2. 책임(Responsibilities) : 객체가 할 수 있는 일. 각 책임은 객체가 담당하는 전문적인 일 중에서도 단 하나의 영역에 초점을 맞춰야 한다.

3. 협업자(Coolaborators) : 현재 객체의 클래스가 이야기를 나누는 객체의 클래스명. 협업자의 숫자는 가능한 적어야 한다.
```

특정 유스케이스를 골라 실행에 옮기기 위해 객체를 추가하고 수업에 참여한 사람들을 객체로 선정하고 객체와 관련된 CRC 카드를 받는다.

```text
1. 서로 이야기하며 유스케이스를 구헝하는 액티비티를 수행한다.

2. 당신은 협업자와만 이야기를 나눌 수 있다. 만약 협업자가 아닌 다른 사람과 이야기할 필요가 있다면 그 사람과 이야기할 수 있는 협업자에게 말한다. 만약 이것이 불가능하다면 이 사람을 여러분의 CRC 카드 협업자에게 추가한다.

3. 여러분은 무언가를 하기 위해 필요한 정보를 묻는 대신 작업을 하는 데 필요한 정보를 갖고 있는 협업자에게 작업을 해달라고 요청해야 한다. 협업자가 작업을 하기 위해 필요로 하는 약간의 데이터를 넘겨주는 것은 괜찮지만, 데이터 흐름은 최소화하는 것이 좋다.

4. 어떤 작업을 수행해야 하는데 이 일을 할 사람이 아무도 없다면 새로운 클래스(와 CRC 카드)를 생성하거나 기존의 클래스(와 CRC 카드)에 책임을 추가한다.

5. 만약 CRC 카드가 너무 빽빽해지면 이 CRC 카드에 있는 책임의 일부를 처리할 또 다른 클래스(CRC 카드)를 생성해야 한다. 한 클래스의 복잡도는 4X6 인덱스 카드에 적을 수 있는 양으로 제한되어야 한다.

6. 사용하는 단어와 프로세스 모두에서 문제의 '도메인'(회계, 구매 등)에 집중하라. 즉 실제 도메인 전문가가 문제를 해결하는 것처럼 문제를 해결해야 한다. 컴퓨터는 존재하지 않는다고 생각하라. 두 사람이 어떤 일을 하는 과정에서 서로에게 'getX'라 말하는 일은 거의 없을 것이므로 get/set 메소드는 아마 등장하지 않을 것이다.
위 기술한 프로세스가 OO 디자인 프로세스이다. 핵심은 OO 시스템이 객체들 간의 대화 나눔이라는 것이다.
```

> **언제 getter와 setter를 사용해도 괜찮은가?**

- 핵심 추상화를 담당하는 클래스의 객체를 반환하는 getter 메소드는 단순히 필드로의 접근을 제공하는 getter 메소드에 비해 덜 해롭다.

- 데이터 흐름은 최소화해야 하며, 데이터를 꺼내오기보다는 넣고 일처리를 위임하는 것이 좋다.

- JDBC와 같이 절차 지행 경계 레이어에 있는 프로그램은 필연적으로 getter/setter를 사용할 수밖에 없다.

- 스윙과 같이 고도의 유연성을 필요로 하는 경계 레이어에 있는 프로그램 역시 getter/setter를 필요로 한다.

- 하지만 대부분의 프로그래머들이 평소 작성하는 코드는 문제 도메인의 프로그램이며 스윙과 같은 고도의 범용성을 필요로 하지 않는다. 사용하지도 않을 불필요한 유연성을 제공하는 것은 낭비일 뿐이다.

> **getter/setter 이슈 정리**

- 정보는 구현을 감추는 객체에 적절히 캡슐화 되어서 흘러야 한다.

- 유지 보수성은 객체 간에 흐르는 데이터의 양에 반비례 한다.

```text
• 원시 데이터 보다는 객체(이상적으로는 인터페이스)를 넘긴다.

• 꺼내는 모델 보다는 넣는 모델을 사용한다. 협동 객체에 정보를 주고 일을 위임하라.
```

- 도메인 레벨을 직접 모델링하는 비지니스 객체는 getter/setter를 필요로 하는 경우가 거의 없다.

- OO 시스템의 절차적 경계(데이터베이스 인터페이스, UI 생성 클래스 등)에 가까이 갈수록 구현을 감추기 어려워진다. 필요하다면 getter/setter를 조심스럽게 사용하라.

- 범용 라이브러리나 클래스는 완전히 구현을 감출 수 없기 때문에 getter/setter를 사용할 수밖에 없다.

- 구현을 완전히 감출 필요가 없는 Point, Dimension과 같은 데이터 클래스도 있을 수 있다.

---

## `2. 인터페이스로 프로그래밍하기 그리고 몇 개의 생성 패턴`

---

## `3. 라이프 게임`

---

## `4. 소형 데이터베이스 구현하기`

---

## `부록. 디자인 패턴 퀵 레퍼런스`