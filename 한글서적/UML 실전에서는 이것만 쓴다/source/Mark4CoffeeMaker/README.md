# Mark4 Coffee Maker

---

## 커피메이커 개발

- 가장 중요한 본질과 세부사항을 분리한다.
- 온갖 사소한 세부사항을 잠시 잊고 근본 문제에 집중한다.
- 어떻게 하면 커피를 끓일 수 있는가? 이것이 진짜 문제다.

## 어떻게 하면 커피를 끓일 수 있을까?

- 커피 가루에 뜨거운 물을 부어서 우러나온 물을 어떤 용기에 담는 것이다.
- 뜨거운 물은 어디에서 공급할까? 뜨거운 물이 나오는 곳을 ```HotWaterSource(뜨거운 물의 공급원)```라고 부르자.
- 커피를 어디에 담을까? 커피를 담는 곳을 ```ContainmentVessel(담는 용기)```라고 부르자.

## 두 추상화는 클래스가 될 수 있을까?

- 끓이는 장치, 벨브, 끓이는 장치의 감지기가 ```HotWaterSource``` 역할을 맡을 수 있다.
- 온열판과 온열판 감지기가 ```ContainmentVessel``` 역할을 맡을 수 있다.

## 시스템과 사람이 상호 작용할 UserInterface 추가

- 시스템에 사람이 내리는 명령를 기다리고 사람에게 시스템의 상태를 보고한다.

## 유스케이스

### 유스케이스 1 : 사용자가 끓임(Brew) 버튼을 누른다.

- ```UserInterface```는 사용자가 끓임 버튼을 누른 사실을 감지하고 버튼이 눌리면 뜨거운 물의 흐름을 시작(start)한다.
- 뜨거운 물의 흐름을 시작하기 전에 ```ContainmentVessel```, ```HotWaterSource``` 이 둘의 준비완료 여부(isReady)를 체크한다.

### 유스케이스 2 : ContainmentVessel이 준비되어 있지 않다.

- ```ContainmentVessel```은 어떤 시점이든 사용자가 주전자를 빼갈 수도 있다는 점을 감지해야 한다.
- 주전자를 빼가면 ```HotWaterSource```에게 뜨거운 물을 그만보내라고(pause) 하고 반대의 경우 다시 뜨거운 물을 보내라고(resume) 알려주어야 한다.

### 유스케이스 3 : 커피가 다 끓었다.

- 커피가 다 끓으면(done) 물의 흐름을 끊어야 하는데 이 역할은 ```HotWaterSource```, ```ContainmentVessel``` 머신의 구현 방식에 따라 둘 모두 가능하다고 가정할 수 있다.

### 유스케이스 4 : 커피를 모두 마셨다.

- 커피를 다 마셨다(complete, 빈 주전자가 온열기에서 감지될때)는 ```ContainmentVessel```이 감지해야 한다.

## 추상 모델을 실제 구현하기

- 잘 구현된 세 객체의 메서드가 그냥 CoffeeMakerAPI의 함수를 호출하는 방식으로 구현하는 일은 없도록 한다.
- 커피를 끓이는 일이 무엇인지 핵심을 모두 잡아 놓았는데 마크IV라는 특정한 기계에만 묶이도록 한다면 형편없는 설계가 됨을 알아야 한다.
- 즉 세개의 클래스 모두 마크IV에 대해서 알아서는 안된다. 시스템에서 커피를 만든다는 고차원 정책이 구체적 장치에 의존하지 않아야 한다. (DIP)
